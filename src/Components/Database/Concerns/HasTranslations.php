<?php

namespace Initium\LaravelTranslatable\Components\Database\Concerns;

use Illuminate\Support\Facades\DB;
use Initium\LaravelTranslatable\Components\Database\Scopes\TranslationScope;

/**
 * Trait for Eloquent models that have translatable attributes.
 *
 * Automātiski pievieno INNER JOIN ar tulkojumu tabulu,
 * atgriežot tikai ierakstus ar tulkojumu pašreizējā valodā.
 *
 * @mixin \Illuminate\Database\Eloquent\Model
 */
trait HasTranslations
{
    /**
     * Cache for translatable columns from PHP file.
     *
     * @var array<string, array<string>>|null
     */
    protected static ?array $translatableCache = null;

    /**
     * Valoda šai instancei (tiek iestatīta no save($options, $locale)).
     */
    protected ?string $translationLocale = null;

    /**
     * Pending tulkojumu izmaiņas.
     *
     * @var array<string, mixed>
     */
    protected array $pendingTranslations = [];

    /**
     * Boot the trait.
     */
    public static function bootHasTranslations(): void
    {
        static::addGlobalScope(new TranslationScope);
    }

    /**
     * Get the translatable attributes for this model.
     * Reads from cached PHP file generated by `php artisan translatable:cache`.
     *
     * @return array<string>
     *
     * @throws \RuntimeException
     */
    public function getTranslatableAttributes(): array
    {
        if (static::$translatableCache === null) {
            $cachePath = $this->getTranslatableCachePath();

            if (! file_exists($cachePath)) {
                static::$translatableCache = [];
            } else {
                try {
                    $cache = require $cachePath;

                    if (! is_array($cache)) {
                        throw new \RuntimeException(
                            "Translatable cache file at {$cachePath} must return an array, got: ".gettype($cache)
                        );
                    }

                    static::$translatableCache = $cache;
                } catch (\Throwable $e) {
                    throw new \RuntimeException(
                        "Failed to load translatable cache from {$cachePath}: ".$e->getMessage(),
                        0,
                        $e
                    );
                }
            }
        }

        return static::$translatableCache[$this->getTranslationTableName()] ?? [];
    }

    /**
     * Get the cache file path from config.
     */
    protected function getTranslatableCachePath(): string
    {
        $configPath = config('translatable.cache_path', 'bootstrap/cache/translatable.php');

        // Handle relative paths
        if (! str_starts_with($configPath, '/') && ! preg_match('/^[a-zA-Z]:/', $configPath)) {
            return base_path($configPath);
        }

        return $configPath;
    }

    /**
     * Get the translation table name.
     * Uses singular form: products -> product_translations
     */
    public function getTranslationTableName(): string
    {
        $table = $this->getTable();
        $singular = str($table)->singular()->toString();
        $suffix = config('translatable.table_suffix', '_translations');

        return $singular.$suffix;
    }

    /**
     * Get the foreign key name for translations.
     */
    public function getTranslationForeignKey(): string
    {
        $table = $this->getTable();
        $singular = str($table)->singular()->toString();

        return $singular.'_id';
    }

    /**
     * Scope to disable translation join and get all records.
     */
    public function scopeWithoutTranslations($query)
    {
        return $query->withoutGlobalScope(TranslationScope::class);
    }

    /**
     * Iegūt aktīvo valodu (no save() parametra vai app locale).
     */
    protected function getTranslationLocale(): string
    {
        return $this->translationLocale ?? app()->getLocale();
    }

    /**
     * Override setAttribute to handle translatable attributes.
     */
    public function setAttribute($key, $value): mixed
    {
        if (in_array($key, $this->getTranslatableAttributes())) {
            $this->pendingTranslations[$key] = $value;

            return $this;
        }

        return parent::setAttribute($key, $value);
    }

    /**
     * Override getAttribute to check pending translations first.
     */
    public function getAttribute($key): mixed
    {
        // Vispirms pārbaudīt pending (neiesūtītās izmaiņas)
        if (isset($this->pendingTranslations[$key])) {
            return $this->pendingTranslations[$key];
        }

        return parent::getAttribute($key);
    }

    /**
     * Override getDirty to exclude translatable attributes from main table save.
     */
    public function getDirty(): array
    {
        $dirty = parent::getDirty();
        $translatable = $this->getTranslatableAttributes();

        // Noņemt tulkojamus atribūtus no dirty (tie tiks saglabāti translation tabulā)
        $filtered = array_diff_key($dirty, array_flip($translatable));

        // Filter out attributes that are null and don't exist in original attributes
        // or where the original value was not null (prevents overwriting with null)
        foreach ($filtered as $key => $value) {
            if ($value === null && $this->getOriginal($key) !== null) {
                unset($filtered[$key]);
            }
        }

        return $filtered;
    }

    /**
     * Save the model and translations.
     *
     * @param  array<string, mixed>  $options
     */
    public function save(array $options = [], ?string $locale = null): bool
    {
        // Iestatīt locale no parametra
        $this->translationLocale = $locale;

        // Use transaction for atomic save
        return DB::transaction(function () use ($options) {
            $result = parent::save($options);

            // Pēc save - saglabāt pending tulkojumus
            if ($result && ! empty($this->pendingTranslations)) {
                $this->savePendingTranslations();
            }

            // Reset locale pēc save
            $this->translationLocale = null;

            return $result;
        });
    }

    /**
     * Saglabāt pending tulkojumus translation tabulā.
     */
    protected function savePendingTranslations(): void
    {
        $locale = $this->getTranslationLocale();
        $foreignKey = $this->getTranslationForeignKey();

        DB::table($this->getTranslationTableName())
            ->updateOrInsert(
                [$foreignKey => $this->id, 'locale' => $locale],
                $this->pendingTranslations
            );

        $this->pendingTranslations = [];
    }

    /**
     * Save translations for multiple locales at once.
     *
     * @param  array<string, array<string, mixed>>  $translations  ['en' => ['name' => 'Product'], 'lv' => ['name' => 'Produkts']]
     */
    public function saveTranslations(array $translations): bool
    {
        if (empty($translations)) {
            return true;
        }

        return DB::transaction(function () use ($translations) {
            $foreignKey = $this->getTranslationForeignKey();
            $translationTable = $this->getTranslationTableName();

            foreach ($translations as $locale => $attributes) {
                // Filter only translatable attributes
                $translatableData = array_intersect_key(
                    $attributes,
                    array_flip($this->getTranslatableAttributes())
                );

                if (! empty($translatableData)) {
                    DB::table($translationTable)
                        ->updateOrInsert(
                            [$foreignKey => $this->id, 'locale' => $locale],
                            $translatableData
                        );
                }
            }

            return true;
        });
    }
}
